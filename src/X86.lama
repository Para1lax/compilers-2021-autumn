import Fun;
import Collection;
import List;
import Manifest;
import Buffer;
import X86utils;
import SMenv;

-- Exported accessors
fun envString(env) { env [0] () }

fun allocate(env) { env [1] () }

fun push(env, x) { env [2] (x) }

fun pop(env) { env [3] () }

fun pop2(env) { env [4] () }

fun addGlobal(env, name) { env [5] (name) }

fun loc(env, name) { env [6] (name) }

fun getGlobals(env) { env [7] () }

fun getStackSize(env) { env [8] () }

fun peek(env) { env [9] () }

fun isBarrier(env) { env [10] () }

fun setBarrier(env) { env [11] () }

fun setStack(env, l) { env [12] (l) }

fun retrieveStack(env, l) { env [13] (l) }

fun enterFunction(env, fLabel, nL) { env [14] (fLabel, nL) }

fun currentFunction(env) { env [15] () }

fun liveRegisters(env, depth) { env [16] (depth) }

fun staticSize(env) { env [17] () }

-- Codegeneration helper functions
-- Generates code section
fun codeSection(text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
fun dataSection(text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates data definition
fun dataDef(name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates function prologue
fun prologue(fLabel) {
  singletonBuffer (Push  (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("subl", M (sprintf ("$%s_SIZE", fLabel)), esp)  
}

-- Generates function epilogue
fun epilogue(env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", env.currentFunction, env.staticSize * wordSize));

  if compare (env.currentFunction, "main") == 0
  then [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Binop ("xorl", eax, eax) <+ Ret <+ metaDef]
  else case env.pop of
         [y, env] -> [env, singletonBuffer (Mov (y, eax)) <+ Mov (ebp, esp) <+ Pop (ebp) <+ Ret <+ metaDef]
       esac
  fi
}

-- Checks if an operand resides on a stack
fun stackOpnd(opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Checks if an operand resides in memory
fun memOpnd(opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | _     -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move(from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

fun lea (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Lea (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Lea (from, to))
  fi
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
fun suffix(op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  esac
}

fun bool(x) {
  move(L(0), eax) <+ Binop("cmpl", x, eax) <+ Set("ne", "%al") <+> move(eax, x)
}

fun arithmetic(l, r, s, op) {
  move(r, edx) <+ Binop(op, l, edx) <+> move(edx, s)
}

fun comparative(l, r, s, op) {
  move(l, eax) <+ Binop ("cmpl", eax, r) <+> move(L (0), eax) <+ Set (op, "%al") <+> move(eax, s)
}

fun compileBinop(l, r, op, s, env, code) {
  case op of
      "+"  -> [env, code <+> arithmetic(l, r, s, "addl")]
    | "-"  -> [env, code <+> arithmetic(l, r, s, "subl")]
    | "*"  -> [env, code <+> arithmetic(l, r, s, "imull")]
    | "/"  -> [env, code <+> move(r, eax) <+ Cltd <+ IDiv(l) <+> move(eax, s)]
    | "%"  -> [env, code <+> move(r, eax) <+ Cltd <+ IDiv(l) <+> move(edx, s)]
    | "<"  -> [env, code <+> comparative(l, r, s, "l")]
    | "<=" -> [env, code <+> comparative(l, r, s, "le")]
    | "==" -> [env, code <+> comparative(l, r, s, "e")]
    | "!=" -> [env, code <+> comparative(l, r, s, "ne")]
    | ">=" -> [env, code <+> comparative(l, r, s, "ge")]
    | ">"  -> [env, code <+> comparative(l, r, s, "g")]
    | "!!" -> [env, code <+> bool(l) <+> bool(r) <+ Binop("orl ", l, eax) <+> move(eax, s)]
    | "&&" -> [env, code <+> bool(l) <+> bool(r) <+ Binop("andl", l, eax) <+> move(eax, s)]
    | _    -> failure ("Unknown operand: %s", op)
  esac
}


fun pushRegs(regs) {
  foldl(fun(pushes, reg) { pushes <+ Push (reg) }, emptyBuffer(), regs)
}

fun popRegs(regs) {
  foldr(fun(pops, reg) { pops <+ Pop (reg) }, emptyBuffer(), regs)
}

fun pushArgs(env, nargs) {
  var environ = env, pushes = emptyBuffer();
  for var n; n := 0, n < nargs, n := n + 1 do
    case pop(environ) of [s, e] -> 
      environ := e; pushes := pushes <+ Push (s)
    esac
  od;   
  [environ, pushes]
}

fun popArgs(nargs) {
  singletonBuffer (Binop ("addl", L (wordSize * nargs), esp))
}


fun compileItem([env, scode], item) {
  var code = scode <+ Meta ("# " ++ showSMInsn (item) ++ "\n");
  case item of
    READ ->
      case allocate(env) of [s, env] -> 
        [env, code <+ Call ("Lread") <+ Mov (eax, s)]
      esac             
  | WRITE ->
      case pop(env) of [s, env] -> 
        [env, code <+ Push (s) <+ Call ("Lwrite") <+ Pop (eax)]
      esac
  | ST (x) ->
      case peek(env) of s -> 
        [env, code <+> move(s, env.loc(x))]
      esac
  | STI ->
      case pop(env) of [lv, env] -> 
        case peek(env) of rv ->
          [env, code <+> move(lv, I (0, rv)) <+> move(lv, rv)]
        esac
      esac
  | LD (x) ->
      case allocate(env) of [s, env] -> 
        [env, code <+> move(env.loc(x), s)]
      esac
  | LDA (x) ->
      case allocate(env) of [s, env] ->
        [env, code <+> lea(env.loc(x), s)]
      esac
  | CONST (n) ->
      case allocate(env) of [s, env] -> 
        [env, code <+> move(L(n), s)]
      esac
  | BINOP (op) ->
      case pop2(env) of [l, r, env] -> 
        case allocate(env) of [s, env] ->
          compileBinop(l, r, op, s, env, code)
        esac
      esac
  | JMP (lab) ->
      [setBarrier(env.setStack(lab)), code <+ Jmp (lab)]
  | CJMP (postfix, lab) ->
      case pop(env) of [s, env] ->
        [env.setStack(lab), code <+> bool(s) <+ CJmp (postfix, lab)]
      esac
  | LABEL (lab) ->
      var nextEnv = if isBarrier(env) then env.retrieveStack(lab) else env fi;
      [nextEnv, code <+ Label (lab)]
  | DROP ->
      case pop(env) of [_, env] -> 
        [env, code] 
      esac
  | DUP ->
      case peek(env) of v ->
        case allocate(env) of [s, env] ->
          [env, code <+> move(v, s)]
        esac
      esac
  | GLOBAL (x) ->
      [env.addGlobal(x), code]
  | BEGIN (flab, nargs, nvars) -> 
      [env.enterFunction(flab, nvars), code <+> prologue(flab)]
  | END ->
      case epilogue(env) of [env, epcode] ->
        [env, code <+> epcode]
      esac
  | CALL (flab, nargs) -> 
      case env.liveRegisters(nargs) of regs ->
        case env.pushArgs(nargs) of [env, argsPush] ->
          case allocate(env) of [s, env] ->
            [env, code <+> pushRegs(regs) <+> argsPush <+ Call (flab) <+> 
            popArgs(nargs) <+> popRegs(regs) <+> move(eax, s)]
          esac
        esac
      esac                      
  | _ -> failure ("codegeneration for instruction %s is not yet implemented\n", item.string)
  esac  
}


-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (env, code) {
  foldl(compileItem, [env, emptyBuffer ()], code)
}

-- A top-level codegeneration function. Takes a driver's environment and a stack machine program,
-- compiles the program into machine code, and compiles the machine code into an executable
public fun compileX86 (args, code) {
  case compile (initX86Env(), code) of [env, code] ->
    var asmFile = args.getBaseName ++ ".s",
      runtime = case getEnv ("LAMA_RUNTIME") of
        #val -> "../runtime/"
      | path     -> path
      esac ++ "/runtime.o";
    fwrite(asmFile, map(insnString, 
      getBuffer $ singletonBuffer (Meta ("\t.global\tmain\n")) <+> dataSection (
        listBuffer $ map (dataDef, getGlobals (env))
      ) <+> codeSection (code)
    ).stringcat);
                    
    system ({"gcc -g -m32 -o ", args.getBaseName, " ", runtime, " ", asmFile}.stringcat)
  esac
}
