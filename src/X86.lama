-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import Fun;
import SMenv;
import Collection;
import List;
import Manifest;
import Buffer;
import X86utils;
import SMenv;

-- Exported accessors
fun envString(env) { env [0] () }

fun allocate(env) { env [1] () }

fun push(env, x) { env [2] (x) }

fun pop(env) { env [3] () }

fun pop2(env) { env [4] () }

fun addGlobal(env, name) { env [5] (name) }

fun loc(env, name) { env [6] (name) }

fun getGlobals(env) { env [7] () }

fun getStackSize(env) { env [8] () }

fun peek(env) { env [9] () }

fun isBarrier(env) { env [10] () }

fun setBarrier(env) { env [11] () }

fun setStack(env, l) { env [12] (l) }

fun retrieveStack(env, l) { env [13] (l) }

fun enterFunction(env, fLabel, nL) { env [14] (fLabel, nL) }

fun currentFunction(env) { env [15] () }

fun liveRegisters(env, depth) { env [16] (depth) }

fun addString (env, s) { env [17] (s) }

fun getStrings (env) { env [18] () }

fun staticSize(env) { env [19] () }

-- Creates an initial environment
fun initEnv () {
  makeEnv ({}, 0, emptySet (compare), emptySet (compare), 0, false, emptyMap (compare), "", 0)
}

-- Codegeneration helper functions
-- Generates code section
fun codeSection(text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
fun dataSection(text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates integer definition
fun intDef (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates string definition
fun stringDef ([name, vl]) {
  Meta (sprintf ("%s:\t.string\t""%s""\n", name, vl))
}

-- Generates function prologue
fun prologue(fLabel) {
  singletonBuffer (Push  (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("subl", M (sprintf ("$%s_SIZE", fLabel)), esp)  
}

-- Generates function epilogue
fun epilogue(env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", env.currentFunction, env.staticSize * wordSize));

  if compare (env.currentFunction, "main") == 0
  then [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Binop ("xorl", eax, eax) <+ Ret <+ metaDef]
  else case env.pop of
         [y, env] -> [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Mov (y, eax) <+ Ret <+ metaDef]
       esac
  fi
}

-- Checks if an operand resides on a stack
fun stackOpnd(opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Checks if an operand resides in memory
fun memOpnd(opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | _     -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move(from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

fun lea (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Lea (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Lea (from, to))
  fi
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
fun suffix(op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  esac
}

fun bool(x) {
  move(L(0), eax) <+ Binop("cmpl", x, eax) <+ Set("ne", "%al") <+> move(eax, x)
}

fun arithmetic(l, r, s, op) {
  move(r, edx) <+ Binop(op, l, edx) <+> move(edx, s)
}

fun comparative(l, r, s, op) {
  move(l, eax) <+ Binop ("cmpl", eax, r) <+> move(L (0), eax) <+ Set (op, "%al") <+> move(eax, s)
}


-- Boxes an immediate value
fun makeBox (n) {
  n * 2 + 1
}

-- Generates a fixednum representation
-- conversion
fun toFixedNum (r) {
  singletonBuffer (Sal1 (r)) <+ Or1 (r)
}

fun compileBinop(l, r, op, s, env, code) {
  case op of
      "+"  -> [env, code <+> arithmetic(l, r, s, "addl")]
    | "-"  -> [env, code <+> arithmetic(l, r, s, "subl")]
    | "*"  -> [env, code <+> arithmetic(l, r, s, "imull")]
    | "/"  -> [env, code <+> move(r, eax) <+ Cltd <+ IDiv(l) <+> move(eax, s)]
    | "%"  -> [env, code <+> move(r, eax) <+ Cltd <+ IDiv(l) <+> move(edx, s)]
    | "<"  -> [env, code <+> comparative(l, r, s, "l")]
    | "<=" -> [env, code <+> comparative(l, r, s, "le")]
    | "==" -> [env, code <+> comparative(l, r, s, "e")]
    | "!=" -> [env, code <+> comparative(l, r, s, "ne")]
    | ">=" -> [env, code <+> comparative(l, r, s, "ge")]
    | ">"  -> [env, code <+> comparative(l, r, s, "g")]
    | "!!" -> [env, code <+> bool(l) <+> bool(r) <+ Binop("orl ", l, eax) <+> move(eax, s)]
    | "&&" -> [env, code <+> bool(l) <+> bool(r) <+ Binop("andl", l, eax) <+> move(eax, s)]
    | _    -> failure ("Unknown operand: %s", op)
  esac
}


fun pushRegs(regs) {
  foldl(fun(pushes, reg) { pushes <+ Push (reg) }, emptyBuffer(), regs)
}

fun popRegs(regs) {
  foldr(fun(pops, reg) { pops <+ Pop (reg) }, emptyBuffer(), regs)
}

fun pushArgs(env, nargs, nonstacks) {
  var environ = env, pushes = emptyBuffer();
  for var n; n := 0, n < nargs, n := n + 1 do
    case pop(environ) of [s, e] -> 
      environ := e; pushes := pushes <+ Push (s)
    esac
  od;   
  [environ, foldl(fun(code, nonstack) { code <+ Push (nonstack) }, pushes, nonstacks)]
}

fun popArgs(nargs, nonstacks) {
  singletonBuffer (Binop ("addl", L (wordSize * (nargs + nonstacks.size)), esp))
}

fun callFunction(env, code, flab, nargs, nonstacks) {
  case liveRegisters(env, nargs) of regs ->
    case pushArgs(env, nargs, nonstacks) of [env, argsPush] ->
      case allocate(env) of [s, env] ->
        [env, code <+> pushRegs(regs) <+> argsPush <+ Call (flab) <+> 
        popArgs(nargs, nonstacks) <+> popRegs(regs) <+> move(eax, s)]
      esac
    esac
  esac          
}


fun compileItem([env, scode], item) {
  var code = scode <+ Meta ("# " ++ showSMInsn (item) ++ "\n");
  -- printf("\n=== %s", item.string);
  case item of
    ST (x) ->
      case peek(env) of s -> 
        [env, code <+> move(s, loc(env, x))]
      esac
  | STI ->
      case pop(env) of [lv, env] -> 
        case peek(env) of rv ->
          [env, code <+> move(lv, I (0, rv)) <+> move(lv, rv)]
        esac
      esac
  | STA -> 
      callFunction(env, code, "Bsta", 3, {})
  | LD (x) ->
      case allocate(env) of [s, env] -> 
        [env, code <+> move(loc(env, x), s)]
      esac
  | LDA (x) ->
      case allocate(env) of [s, env] ->
        [env, code <+> lea(loc(env, x), s)]
      esac
  | CONST (n) ->
      case allocate(env) of [s, env] -> 
        [env, code <+> move(L (n), s)]
      esac
  | BINOP (op) ->
      case pop2(env) of [l, r, env] -> 
        case allocate(env) of [s, env] ->
          compileBinop(l, r, op, s, env, code)
        esac
      esac
  | JMP (lab) ->
      [setBarrier(setStack(env, lab)), code <+ Jmp (lab)]
  | CJMP (postfix, lab) ->
      case pop(env) of [s, env] ->
        [setStack(env, lab), code <+> bool(s) <+ CJmp (postfix, lab)]
      esac
  | LABEL (lab) ->
      var nextEnv = if isBarrier(env) then retrieveStack(env, lab) else env fi;
      [nextEnv, code <+ Label (lab)]
  | DROP ->
      case pop(env) of [_, env] -> 
        [env, code] 
      esac
  | DUP ->
      case peek(env) of v ->
        case allocate(env) of [s, env] ->
          [env, code <+> move(v, s)]
        esac
      esac
  | GLOBAL (x) ->
      [addGlobal(env, x), code]
  | BEGIN (flab, nargs, nvars) -> 
      [enterFunction(env, flab, nvars), code <+> prologue(flab)]
  | END ->
      case epilogue(env) of [env, epcode] ->
        [env, code <+> epcode]
      esac
  | CALL (flab, nargs) ->
      callFunction(env, code, flab, nargs, {})
  | BUILTIN (f, nargs) -> 
      callFunction(env, code, "L" ++ f, nargs, {})   
  | STRING (literal) ->
      case addString(env, literal) of [env, slab] ->
        case allocate(env) of [s, env] ->
          callFunction(env, code <+> move(M ("$" ++ slab), s), "Bstring", 1, {})
        esac
      esac    
  | ARRAY (n) -> 
      callFunction(env, code, "Barray", n, { L (n) })
  | ELEM ->
      callFunction(env, code, "Belem", 2, {})
  | SEXP (name, nargs) -> 
      case allocate(env) of [s, env] -> 
        callFunction(env, code <+> move(L (tagHash(name)), s), "Bsexp", nargs + 1, { L (nargs+1) })
      esac
  | _ -> failure ("codegeneration for instruction %s is not yet implemented\n", item.string)
  esac  
}


-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (env, code) {
  foldl(compileItem, [env, emptyBuffer ()], code)
}

-- A top-level codegeneration function. Takes a driver's environment and a stack machine program,
-- compiles the program into machine code, and compiles the machine code into an executable
public fun compileX86 (args, code) {
  case compile (initX86Env(), code) of [env, code] ->
    var asmFile = args.getBaseName ++ ".s",
      runtime = case getEnv ("LAMA_RUNTIME") of
        #val -> "../runtime/"
      | path -> path
      esac ++ "/runtime.o";

    fwrite (asmFile, map (insnString, 
      getBuffer $ singletonBuffer (Meta ("\t.global\tmain\n")) <+> 
      dataSection (
        listBuffer (map (intDef, getGlobals (env))) <+>
        listBuffer (map (stringDef, getStrings (env)))) <+>
        codeSection (code)                   
      ).stringcat
    );
                    
    system ({"gcc -g -m32 -o ", args.getBaseName, " ", runtime, " ", asmFile}.stringcat)
  esac
}
