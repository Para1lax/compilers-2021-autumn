-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

fun logEval(message) {
  --printf("->> %s\n", message)
  skip
}

fun logComp(message) {
  --printf(">> %s\n", message)
  skip
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     logEval("from init: " ++ l.string);
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}


-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
-- fun eval (env, c@[stack, state, world], insns) {
  -- recursive calls cause stack overflow -> use loop instead of recursion
-- }
-- returns [evalEnv, [stack, state, world], nextFlow] after execution one command
fun eval (env, c@[stack, state, world], insns) {
  case insns of cur:next ->
    logEval(cur.string);
    case cur of 
      CONST (n) -> [env, [n:stack, state, world], next]
    | LD (x) -> [env, [x.state:stack, state, world], next]
    | LDA (x) -> [env, [Ref(x):stack, state, world], next]
    | ST (x) -> 
      case stack of v:rest -> 
        [env, [rest, state <- [x, v], world], next]
      esac 
    | STI ->
        case stack of rv:Ref(lv):rest -> 
          [env, [rv:rest, state <- [lv, rv], world], next]
        esac
    | BINOP (op) ->
        case stack of y:x:rest -> 
          [env, [evalOp(op, x, y):rest, state, world], next]
        esac
    | READ ->
        case readWorld(world) of [v, next_world] ->
          [env, [v:stack, state, next_world], next]
        esac
    | WRITE ->
        case stack of v:rest -> 
          [env, [rest, state, writeWorld(v, world)], next]
        esac
    | JMP (lab) -> [env, c, fromLabel(env, lab)]
    | CJMP (postfix, lab) ->
        case stack of v:rest ->
          fun makeJump(op) {
            if op(v, 0) then [env, [rest, state, world], fromLabel(env, lab)]
            else [env, [rest, state, world], next] fi
          }
          case postfix of
            "l" -> makeJump(infix <)
          | "le" -> makeJump(infix <=)
          | "e" -> makeJump(infix ==)
          | "ne" -> makeJump(infix !=)
          | "ge" -> makeJump(infix >=)
          | "g" -> makeJump(infix >)
          esac
        esac
    | LABEL (lab) -> [env, c, next]  
    | DROP ->
        case stack of v:rest -> 
          [env, [rest, state, world], next] 
        esac
    | _ -> failure("SM evaluator failed at %s\n", cur.string)
     esac
  esac   
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  var env = insns.initEvalEnv;
  var config = [{}, emptyState, input.createWorld];
  var flow = insns;
  while flow.size > 0 do
    case eval(env, config, flow) of
      [e, c, f] -> env := e; config := c; flow := f
    esac
  od;
  config[2].getOutput
  
  -- eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  fun label (lab, labUsed) {
    if labUsed
    then singletonBuffer (LABEL (lab))
    else emptyBuffer ()
    fi
  }
  
  fun compile (lab, env, stmt) {
    case stmt of
      Read (x) -> logComp("read " ++ x.string);
        [false, env, singletonBuffer (READ) <+ ST (x)]
    | Write (e) -> logComp("write" ++ e.string);
        case compile(lab, env, e) of
          [_, env, code] -> [false, env, code <+ WRITE]
        esac
    | Assn (x, e) -> logComp("assign " ++ e.string ++ " to " ++ x.string);
        case compile(lab, env, x) of 
          [_, env, lcode] -> case compile(lab, env, e) of
            [_, env, rcode] -> [false, env, lcode <+> rcode <+ STI]
          esac
        esac
    | Seq (s1, s2) -> 
        case env.genLabel of [s2Lab, env] ->
          case compile (s2Lab, env, s1) of [s2LabUsed, env, s1Code] ->
            case compile (lab, env, s2) of [labUsed, env, s2Code] -> 
              [labUsed, env, s1Code <+> label(s2Lab, s2LabUsed) <+> s2Code]
            esac
          esac
        esac
    | If (condition, true_branch, false_branch) -> logComp("if " ++ condition.string);
        case env.genLabels(3) of [true_start, false_start, endif, env] ->
          case compile(endif, env, true_branch) of [true_used, env, true_code] ->
            case compile(endif, env, false_branch) of [false_used, env, false_code] ->
              case compile(true_start, env, condition) of [cond_used, env, cond_code] ->
                [true, env, cond_code <+ CJMP ("e", false_start) <+> 
                label(true_start, true_used) <+> true_code <+ JMP (endif) <+
                LABEL (false_start) <+> false_code <+ LABEL (endif)]
              esac
            esac
          esac
        esac
    | While (expr, seq) -> logComp("while " ++ expr.string);
        case env.genLabels(2) of [check_lab, stmt_lab, env] ->
          case compile(check_lab, env, seq) of [lab_used, env, body] ->
            case compile(lab, env, expr) of [_, env, cond_code] ->
              [false, env, singletonBuffer(JMP (check_lab)) <+ LABEL (stmt_lab) <+> 
              body <+ LABEL (check_lab) <+> cond_code <+ CJMP ("ne", stmt_lab)]
            esac
          esac
        esac
    | DoWhile (seq, expr) -> logComp("dowhile " ++ expr.string);
        case env.genLabels(2) of [check_lab, stmt_lab, env] ->
          case compile(check_lab, env, seq) of [lab_used, env, body] ->
            case compile(lab, env, expr) of [_, env, cond_code] ->
              [false, env, singletonBuffer(LABEL (stmt_lab)) <+> body <+>
              label(check_lab, lab_used) <+> cond_code <+ CJMP ("ne", stmt_lab)]
            esac
          esac
        esac
    | Skip -> logComp("skip");
        [false, env, emptyBuffer ()]
    | Var (x) -> logComp("var " ++ x.string);
        [false, env, singletonBuffer (LD (x))]
    | Ref (x) -> logComp("ref " ++ x.string);
        [false, env, singletonBuffer (LDA (x))]
    | Const (n) -> logComp("const " ++ n.string);
        [false, env, singletonBuffer (CONST (n))]
    | Binop (op, l, r) -> logComp("binop " ++ op);
        case compile(lab, env, l) of [_, env, x] -> 
          case compile(lab, env, r) of [_, env, y] ->
            [false, env, x <+> y <+ BINOP (op)]
          esac
        esac
    | Ignore (e) -> logComp("ignore " ++ e.string);
        case compile(lab, env, e) of [_, env, code] -> [false, env, code <+ DROP] esac
    | _  ->  failure("SM compilation is not implemented for %s\n", stmt.string)
    esac
  }

  case initCompEnv ().genLabel of
    [endLab, env] ->
       case compile (endLab, env, stmt) of [endLabUsed, _, code] -> 
         getBuffer $ code <+> label (endLab, endLabUsed) 
       esac
  esac
}
