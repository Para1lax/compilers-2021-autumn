-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}


fun convertToBinop([association, opList]) {
  [association, map (fun (op) {
      [s(op), fun (l, op, r) { Binop(op, l, r) }]
    }, opList)]
    
}

-- Primary expression
var primary = memo $ eta syntax (
    x=decimal { Const (x.stringInt) } 
  | x=lident  { Var (x) } 
  | inbr[s("("), exp, s(")")]
),
  exp = memo $ eta expr (map (convertToBinop, {
      [Left, { "!!" }],
      [Left, { "&&" }],
      [Nona, { "<", "<=", "==", "!=", ">=", ">" }],
      [Left, { "+", "-" }],
      [Left, { "*", "/", "%"}]
    }), primary);
    

var stmt = memo $ eta syntax (
    kRead x=inbr[s("("), lident, s(")")] { Read (x) }
  | kWrite e=inbr[s("("), exp, s(")")] { Write (e) }
  | kSkip { Skip }
  | x=lident s[":="] e=exp { Assn (x, e) }
  | cur=stmt s[";"] next=stmt end { Seq (cur, next) }
);
   

-- Public top-level parser
public parse = stmt;
             
