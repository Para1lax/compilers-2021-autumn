-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}


fun convertToBinop([association, opList]) {
  [association, map (fun (op) {
      [s(op), fun (l, op, r) { Binop(op, l, r) }]
    }, opList)]
    
}

-- Primary expression
var primary = memo $ eta (
    decimal @ fun(x) { Const (x.stringInt) } 
  | lident @ fun(x) { Var (x) } 
  | inbr(s("("), exp, s(")"))
),
  exp = memo $ eta expr (map (convertToBinop, {
      [Left, { "!!" }],
      [Left, { "&&" }],
      [Nona, { "<", "<=", "==", "!=", ">=", ">" }],
      [Left, { "+", "-" }],
      [Left, { "*", "/", "%"}]
    }), primary);
    

var makeIf = memo $ eta syntax (
  condition=exp kThen branch=sequencer elses=branching { 
    If (condition, branch, elses)
  }
), 
  branching = memo $ eta syntax (
    kElse branch=sequencer kFi { branch }
  | kElif elifBody=makeIf { elifBody }
  | kFi { Skip }
),
  stmt = memo $ eta syntax (
    kRead x=inbr[s("("), lident, s(")")] { Read (x) }
  | kWrite e=inbr[s("("), exp, s(")")] { Write (e) }
  | kSkip { Skip }
  | x=lident s[":="] e=exp { Assn (x, e) }
  | kIf ifBody=makeIf { ifBody }
  | kWhile condition=exp kDo body=sequencer kOd { While (condition, body) }
  | kDo body=sequencer kWhile condition=exp kOd { DoWhile (body, condition) }
  | kFor initial=stmt s[","] e=exp s[","] next=stmt kDo body=sequencer kOd {
      Seq (initial, While (e, Seq (body, next)))
    }
),
 sequencer = memo $ eta syntax (
   cur=stmt s[";"] next=sequencer { Seq(cur, next) } | stmt
);

-- Public top-level parser
public parse = sequencer;
             
